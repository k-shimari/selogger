
# Selogger

SELogger is a tool to record an execution trace of a Java program.

## Build

Build a jar file with Maven.

        mvn package

SELogger uses ASM (http://asm.ow2.org/) for injecting logging code.
The class names are shaded by maven-shade-plugin so that 
SELogger can manipulate a program using ASM. 

### How to Build for JDK7

selogger works with JDK 7 while selogger's test cases requires JDK 8 to test the behavior of INVOKEDYNAMIC instructions.
If you would like to build a jar file for JDK7, please skip compilation of test classes as follows.
  - Prepare JDK 7 and Maven.
  - Replace the JDK version `1.8` with `1.7` for the `maven-compiler-plugin` in `pom.xml`.
  - Execute `mvn package -Dmaven.test.skip=true`.

## Usage

Execute your program with the Java Agent.

        java -javaagent:path/to/selogger-0.2.jar [Application Options]

The agent accepts options.  Each option is specified by `option=value` style with commas (","). For example:

        java -javaagent:path/to/selogger-0.2.jar=output=dirname,format=freq [Application Options]


### Output Options

The `output=` option specifies a directory to store an execution trace.  
The directory is automatically created if it does not exist.
The default output directory is `selogger-output`.

The `format=` option specifies an output format.  The default is `latest` format.
  * `freq` mode records only a frequency table of events.
  * `latest` mode records the latest event data with timestamp and thread ID for each bytecode location. 
  * `nearomni` mode is an alias of `latest`.
  * `latest-simple` mode records only the latest event data for each bytecode location.
  * `discard` mode discard event data, while it injects logging code into classes.

In `latest` and `latesttime` mode, two additional options are available:
  * `size=` specifies the size of buffers.  The default is 32.
  * `keepobj=true` keeps objects in buffers to avoid GC.  While it may consume memory, more information is recorded.


### Logging Target Options

The `weave=` option specifies events to be recorded. Supported event groups are: 

  * EXEC (entry/exit)
  * CALL (call)
  * PARAM (parameters for method entries and calls)
  * FIELD (field access)
  * ARRAY (array creation and access)
  * OBJECT (constant object usage)
  * SYNC (synchronized blocks)
  * LOCAL (local variables)
  * LABEL (conditional branches)

The default configuration records EXEC, CALL, PARAM, FIELD, ARRAY, OBJECT, and SYNC. 

The selogger inserts logging code into all the classes except for system classes: `sun/`,`com/sun/`, `java/`, and `javax/`.
You can add a prefix of class names whose behavior is excluded from the logging process using `e=` option.  Use multiple `e=` options to enumerate class paths.



### Option for Troubleshooting

The `dump=true` option stores class files including logging code into the output directory. It may help a debugging task if invalid bytecode is generated. 


## Package Structure

SELogger comprises three sub-packages: `logging`, `reader`, and `weaver`.

  - The `weaver` sub-package is an implementation of Java Agent.  
    - RuntimeWeaver class is the entry point of the agent.  It calls ClassTransformer to inject logging instructions into target classes.
  - The `logging` sub-package implements logging features.
    - Logging class is the entry point of the logging feature.  It records runtime events in files.
  - The `reader` sub-package implements classes to read log files.
    - LogPrinter class is an example to read `.slg` files generated by logging classes. 

The runtime events are listed in `selogger.EventType` class. 
The following table is a list of events.  
An event instance is often recorded with a runtime value; the details are explained in the EventType class.

|Event Category|Event Names|
|:-------------|-----------|
|Method Execution (EXEC)|METHOD_ENTRY, METHOD_NORMAL_EXIT, METHOD_EXCEPTIONAL_EXIT (Entry and Exit), METHOD_PARAM, METHOD_OBJECT_INITIALIZED (Formal parameters related to method entry events), METHOD_THROW (Exception handling)|
|Method Call (CALL)|CALL, CALL_RETURN (A method call instruction), CALL_PARAM (Actual parameters), NEW_OBJECT, NEW_OBJECT_CREATED (constructor call), INVOKE_DYNAMIC, INVOKE_DYNAMIC_PARAM, INVOKE_DYNAMIC_RESULT (INVOKEDYNAMIC instruction), | 
|Field access (FIELD)|GET_INSTANCE_FIELD, GET_INSTANCE_FIELD_RESULT, GET_STATIC_FIELD, PUT_INSTANCE_FIELD, PUT_INSTANCE_FIELD_VALUE, PUT_INSTANCE_FIELD_BEFORE_INITIALIZATION, PUT_STATIC_FIELD|
|Array access (ARRAY)|ARRAY_LOAD, ARRAY_LOAD_INDEX, ARRAY_LOAD_RESULT (array read instruction), ARRAY_STORE, ARRAY_STORE_INDEX, ARRAY_STORE_VALUE (array write instruction), NEW_ARRAY, NEW_ARRAY_RESULT, MULTI_NEW_ARRAY, MULTI_NEW_ARRAY_OWNER, MULTI_NEW_ARRAY_ELEMENT (`new` instruction for arrays), ARRAY_LENGTH, ARRAY_LENGTH_RESULT (.length)|
|Synchronized block (SYNC)|MONITOR_ENTER, MONITOR_ENTER_RESULT, MONTIOR_EXIT|
|Object manipulation (OBJECT)|OBJECT_CONSTANT_LOAD, OBJECT_INSTANCEOF, OBJECT_INSTANCEOF_RESULT|
|Local variables (LOCAL)|LOCAL_LOAD, LOCAL_STORE, LOCAL_INCREMENT (local variable access), RET (subroutine call)|
|Control-flow events (LABEL)|CATCH_LABEL, CATCH, LABEL, JUMP, DEVIDE|

 
## Differences from master branch version

The execution trace recorded in this version is incompatible with the master branch version.
The major differences are:
 * Simplified data format
 * Simplified instrumentation implementation
 * Simplified logging implementation (easy to extend)
 * Supported load-time weaving
 * Supported tracing jumps caused by exceptions
 * Supported fixed-size buffer logging
 * Improved reliability with JUnit test cases
