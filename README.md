
# Selogger

SELogger is a tool to record an execution trace of a Java program.

## Build

Build a jar file with Maven.

        mvn package

SELogger uses ASM (http://asm.ow2.org/) for injecting logging code.
The class names are shaded by maven-shade-plugin so that 
SELogger can manipulate a program using ASM. 

### How to Build for JDK7

selogger works with JDK 7 while selogger's test cases requires JDK 8 to test the behavior of INVOKEDYNAMIC instructions.
If you would like to build a jar file for JDK7, please skip compilation of test classes as follows.
  - Prepare JDK 7 and Maven.
  - Replace the JDK version `1.8` with `1.7` for the `maven-compiler-plugin` in `pom.xml`.
  - Execute `mvn package -Dmaven.test.skip=true`.

## Usage

Execute your program with the Java Agent.

        java -javaagent:path/to/selogger-0.2.jar [Application Options]

The agent accepts options.  Each option is specified by `option=value` style with commas (","). For example:

        java -javaagent:path/to/selogger-0.2.jar=output=dirname,format=freq [Application Options]


### Output Options

The `output=` option specifies a directory to store an execution trace.  
The directory is automatically created if it does not exist.
The default output directory is `selogger-output`.

The `format=` option specifies an output format.  The default is `latest` format.
  * `freq` mode records only a frequency table of events.
  * `latest` mode records the latest event data with timestamp and thread ID for each bytecode location. 
  * `nearomni` mode is an alias of `latest`.
  * `latest-simple` mode records only the latest event data for each bytecode location.
  * `discard` mode discard event data, while it injects logging code into classes.

In `latest` and `latesttime` mode, two additional options are available:
  * `size=` specifies the size of buffers.  The default is 32.
  * `keepobj=false` keeps objects using weak references to avoid the impact of GC.  It reduces memory consumption, while some object information may be lost.


### Logging Target Options

The `weave=` option specifies events to be recorded. Supported event groups are: 

  * EXEC (entry/exit)
  * CALL (call)
  * PARAM (parameters for method entries and calls)
  * FIELD (field access)
  * ARRAY (array creation and access)
  * OBJECT (constant object usage)
  * SYNC (synchronized blocks)
  * LOCAL (local variables)
  * LABEL (conditional branches)

The default configuration records all events. 

The selogger inserts logging code into all the classes except for system classes: `sun/`,`com/sun/`, `java/`, and `javax/`.
You can add a prefix of class names whose behavior is excluded from the logging process using `e=` option.  Use multiple `e=` options to enumerate class paths.



### Option for Troubleshooting

The `dump=true` option stores class files including logging code into the output directory. It may help a debugging task if invalid bytecode is generated. 


## Package Structure

SELogger comprises three sub-packages: `logging`, `reader`, and `weaver`.

  - The `weaver` sub-package is an implementation of Java Agent.  
    - RuntimeWeaver class is the entry point of the agent.  It calls ClassTransformer to inject logging instructions into target classes.
  - The `logging` sub-package implements logging features.
    - Logging class is the entry point of the logging feature.  It records runtime events in files.
  - The `reader` sub-package implements classes to read log files.
    - LogPrinter class is an example to read `.slg` files generated by logging classes. 

The runtime events are listed in `selogger.EventType` class. 

The following table is a list of events.  
An event instance is often recorded with a runtime value; the details are explained in the EventType class.

|Event Category         |Event Name                |Timing       |Recorded Data|
|:----------------------|:-------------------------|:------------|:--------------------|
|Method Execution (EXEC)|METHOD_ENTRY              |The method is entered, before any instructions in the method is executed|Receiver object if the method is an instance method|
|                       |METHOD_PARAM              |Immediately after METHOD_ENTRY, before any instructions in the method is executed.  The number of the events is the same as the number of formal parameters.|Parameter given to the method|
|                       |METHOD_NORMAL_EXIT        |Before a return instruction (one of RETURN, IRETURN, ARETURN, LRETURN, FRETURN, or DRETURN) is executed|Returned value from the method (= The value passed to the return instruction)|
|                       |METHOD_EXCEPTIONAL_EXIT   |When the method is exiting by an exception|Exception thrown from the method to the caller| 
|                       |METHOD_OBJECT_INITIALIZED |Immediately after execution of `this()` or `super()` in a constructor, before any other instructions in the constructor is executed|Object initialized by the constructor|
|                       |METHOD_THROW              |Before a throw instruction (ATHROW) is executed|Exception thrown by the throw statement|
|Method Call (CALL)     |CALL                      |Before a method is called by a method call instruction (one of INVOKEVIRTUAL, INVOKESTATIC, and INVOKESPECIAL)|Receiver object|
|                       |CALL_PARAM                |Immediately after a CALL event, before executing the method invocation.  The number of the events is the same as the number of actual parameters.|Parameter passed to the callee|
|                       |CALL_RETURN               |After a method invocation instruction is executed|Returned value from the callee|
||NEW_OBJECT|||
||NEW_OBJECT_CREATED (constructor call)|||
||INVOKE_DYNAMIC|||
||INVOKE_DYNAMIC_PARAM|||
||INVOKE_DYNAMIC_RESULT|||
|Field access (FIELD)|GET_INSTANCE_FIELD|Before the instance field is read by a GETFIELD instruction|Object whose field is read|
|                    |GET_INSTANCE_FIELD_RESULT|After the field is read by a GETFIELD instruction|Value read from the field|
|                    |GET_STATIC_FIELD|After the static field is read by a GETSTATIC instruction|Value read from the field|
|                    |PUT_INSTANCE_FIELD|Before the instance field is written by a PUTFIELD instruction|Object whose field is written|
|                    |PUT_INSTANCE_FIELD_VALUE|Immediately after PUT_INSTANCE_FIELD, before the instance field is written|Value written to the field|
|                    |PUT_INSTANCE_FIELD_BEFORE_INITIALIZATION|Before the instance field is written by a PUTFIELD instruction.  This event is used when the object has not been initialized by a constructor but whose field is assigned; for example, when an anonymous inner class object stores the external context into its filed.|Value written to the field|
|                    |PUT_STATIC_FIELD|Before the static field is written by a PUTSTATIC instruction|Value written to the field|
|Array access (ARRAY)|ARRAY_LOAD|Before a value is read from the array by an array load instruction (one of AALOAD, BALOAD, CALOAD, DALOAD, FALOAD, IALOAD, LALOAD, and SALOAD)|Accessed array to read|
|                    |ARRAY_LOAD_INDEX|Immediately after ARRAY_LOAD event.|Accessed index to read|
|                    |ARRAY_LOAD_RESULT|After a value is loaded from the array.|Value read from the array|
|                    |ARRAY_STORE|Before a value is written to the array by an array store instruction (one of AASTORE, BASTORE, CASTORE, DASTORE, FASTORE, IASTORE, LASTORE, and SASTORE)|Accessed array to write|
|                    |ARRAY_STORE_INDEX|Immediately after ARRAY_STORE event|Accessed index to write|
|                    |ARRAY_STORE_VALUE|Immediately after ARRAY_STORE_INDEX event|Value written to the array|
|                    |NEW_ARRAY|||
|                    |NEW_ARRAY_RESULT|||
|                    |MULTI_NEW_ARRAY|||
|                    |MULTI_NEW_ARRAY_OWNER|||
|                    |MULTI_NEW_ARRAY_ELEMENT (`new` instruction for arrays)|||
|                    |ARRAY_LENGTH|Before the length of the array is read by an ARRAYLENGTH instruction|Array whose length is referred|
|                    |ARRAY_LENGTH_RESULT|After the execution of the ARRAYLENGTH instruction|The length of the array|
|Synchronized block (SYNC)|MONITOR_ENTER|||
|                         |MONITOR_ENTER_RESULT|||
|                         |MONTIOR_EXIT|||
|Object manipulation (OBJECT)|OBJECT_CONSTANT_LOAD|||
|                            |OBJECT_INSTANCEOF|||
|                            |OBJECT_INSTANCEOF_RESULT|||
|Local variables (LOCAL)|LOCAL_LOAD|Before the value of the local variable is read by a local variable instruction (one of ALOD, DLOAD, FLOAD, ILOAD, and LLOAD)|Value read from the variable|
|                       |LOCAL_STORE|Before the value is written to the local variable by an instruction (one of ASTORE, DSTORE, FSTORE, ISTORE, and LSTORE) |Value written to the variable|
|                       |LOCAL_INCREMENT|After the local variable is updated by an IINC instruction|Value written to the variable by an increment instruction|
|                       |RET| (subroutine call)||
|Control-flow events (LABEL)|CATCH_LABEL|||
|                           |CATCH|||
|                           |LABEL|||
|                           |JUMP|||
|                           |DEVIDE|||

Note: The event category names Execution and Call come from AspectJ pointcut (execution and call).
 
## Differences from master branch version

The execution trace recorded in this version is incompatible with the master branch version.
The major differences are:
 * Simplified data format
 * Simplified instrumentation implementation
 * Simplified logging implementation (easy to extend)
 * Supported load-time weaving
 * Supported tracing jumps caused by exceptions
 * Supported fixed-size buffer logging
 * Improved reliability with JUnit test cases
